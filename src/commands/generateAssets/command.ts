import * as vscode from "vscode";
import * as fs from "fs";
import * as utility from "../../utility";
import * as path from "path";
import { ns } from "../../extension";

export async function generateAssets() {

    const sln = await utility.getSolutionFile();

    if (!sln) {
        vscode.window.showErrorMessage("No solution file found");
        return;
    }

    const slnFolder = path.dirname(sln);
    const vscodeFolder = path.join(slnFolder, ".vscode");
    const launchFile = path.join(vscodeFolder, "launch.json");
    const tasksFile = path.join(vscodeFolder, "tasks.json");

    fs.mkdirSync(vscodeFolder);

    let lines = fs.readFileSync(sln).toString().split("\n");
    let launchJson = await getLaunchJson(launchFile);
    let tasksJson = await getTaskJson(tasksFile);
    let projects = lines.filter((line: string) => line.indexOf("Project") === 0);

    for (const line of projects) {
        const project = line.split("=")[1].trim();
        let projData = project.split(",");

        let projectPath = projData[1].trim();
        projectPath = projectPath.substring(1, projectPath.length - 1);

        await generateLaunch(launchJson, projectPath);
        await generateTask(tasksJson, projectPath);
    }

    fs.writeFileSync(tasksFile, JSON.stringify(tasksJson, null, 4));
    fs.writeFileSync(launchFile, JSON.stringify(launchJson, null, 4));
}

export async function generateLaunch(launchJson: any, projectPath: string) {
    let projectDir = path.dirname(projectPath);
    let projectExt = path.extname(projectPath);
    let projectName = path.basename(projectPath, projectExt);

    let outputTypeRegex = new RegExp("<OutputType>(.*)</OutputType>");
    let targetFrameworkRegex = new RegExp("<TargetFramework>(.*)<\/TargetFramework>");
    let data = fs.readFileSync(path.join(vscode.workspace.workspaceFolders![0].uri.fsPath, projectPath)).toString();
    let outputTypes = outputTypeRegex.exec(data);

    if (outputTypes === null || outputTypes[1] === null) {
        return;
    }

    // Cant debug a Library project
    if (outputTypes[1] === "Library") {
        return;
    }

    let target = targetFrameworkRegex.exec(data);

    if (target === null) {
        vscode.window.showErrorMessage("Could not find target framework in " + projectPath);
        return;
    }

    let config = vscode.workspace.getConfiguration(ns)

    launchJson.configurations.push({
        name: projectName,
        type: "coreclr",
        request: "launch",
        preLaunchTask: "Build " + projectName,
        program: "${workspaceFolder}/" + projectDir + "/bin/Debug/" + target[1] + "/" + projectName + ".dll",
        cwd: "${workspaceFolder}/" + projectDir,
        console: config.get<string>("launchConfig.console"),
        internalConsoleOptions: config.get<string>("launchConfig.internalConsoleOptions"),
        __autoGenerated__: true
    });
}

export async function generateTask(tasksJson: any, projectPath: string) {
    let projectExt = path.extname(projectPath);
    let projectName = path.basename(projectPath, projectExt);

    let config = vscode.workspace.getConfiguration(ns)

    tasksJson.tasks.push({
        label: "Build " + projectName,
        command: "dotnet",
        type: "process",
        args: [
            "build",
            "${workspaceFolder}/" + projectPath,
            "/property:GenerateFullPaths=true",
            "/consoleloggerparameters:NoSummary"
        ],
        problemMatcher: config.get<string>("taskConfig.problemMatcher"),
        group: "build",
        __autoGenerated__: true
    });
}

export async function getLaunchJson(filepath: string) {
    let launchJson: any = {};

    if (fs.existsSync(filepath)) {
        launchJson = JSON.parse(fs.readFileSync(filepath).toString());

        for (let i = 0; i < launchJson.configurations.length; i++) {
            if (launchJson.configurations[i].__autoGenerated__ !== undefined) {
                launchJson.configurations.splice(i, 1);
            }
        }
    } else {
        launchJson = {
            version: "0.2.0",
            configurations: []
        };
    }

    return launchJson;
}

export async function getTaskJson(filepath: string) {
    let taskJson: any;
    if (fs.existsSync(filepath)) {
        taskJson = JSON.parse(fs.readFileSync(filepath).toString());

        for (let i = 0; i < taskJson.tasks.length; i++) {
            if (taskJson.tasks[i].__autoGenerated__ !== undefined) {
                taskJson.tasks.splice(i, 1);
            }
        }
    } else {
        taskJson = {
            version: "2.0.0",
            tasks: []
        };
    }
    return taskJson;
}
